# Hensu Server Configuration

# HTTP Server
quarkus.http.port=8080
quarkus.http.host=0.0.0.0

# HTTP/3 (QUIC) Support
# Requires TLS and vertx-http3 dependency - uncomment when SSL is configured
# quarkus.http.insecure-requests=redirect
# quarkus.http.ssl-port=8443

# SSL/TLS Configuration (required for HTTP/3)
# For development, generate a self-signed certificate:
#   keytool -genkeypair -alias hensu -keyalg RSA -keysize 2048 \
#     -storetype PKCS12 -keystore hensu-keystore.p12 -validity 365 \
#     -storepass changeit -dname "CN=localhost"
#
# Then uncomment these lines:
# %dev.quarkus.http.ssl.certificate.key-store-file=hensu-keystore.p12
# %dev.quarkus.http.ssl.certificate.key-store-password=changeit

# Production SSL (configure via environment variables or config)
# quarkus.http.ssl.certificate.files=/path/to/cert.pem
# quarkus.http.ssl.certificate.key-files=/path/to/key.pem
# quarkus.http.ssl-port=443

# Application
quarkus.application.name=hensu-server
hensu.stub.enabled=false

# Native image: bundle stub response files so getResourceAsStream works at runtime.
# StubResponseRegistry builds paths dynamically (/stubs/{scenario}/{key}.txt),
# which GraalVM cannot trace statically - explicit inclusion is required.
quarkus.native.resources.includes=stubs/**

# Logging
quarkus.log.level=INFO
quarkus.log.category."io.hensu".level=DEBUG

# JWT Authentication
# HENSU_JWT_PUBLIC_KEY must be set in dev/prod environments.
# Keys are personal per-developer (gitignored). See docs/developer-guide-server.md.
#   Dev:  HENSU_JWT_PUBLIC_KEY=file:/absolute/path/to/repo/dev/keys/publicKey.pem  (in .env)
#   Prod: HENSU_JWT_PUBLIC_KEY=file:/etc/hensu/keys/publicKey.pem  (environment variable)
# Falls back to "unused" so config validation passes in test profiles where JWT is disabled.
mp.jwt.verify.publickey.location=${HENSU_JWT_PUBLIC_KEY:unused}
mp.jwt.verify.issuer=${HENSU_JWT_ISSUER:https://hensu.io}

# Auth policy - require authentication for API and MCP paths
quarkus.http.auth.permission.api.paths=/api/*
quarkus.http.auth.permission.api.policy=authenticated
quarkus.http.auth.permission.mcp.paths=/mcp/connect,/mcp/message
quarkus.http.auth.permission.mcp.policy=authenticated
quarkus.http.auth.permission.mcp-status.paths=/mcp/status,/mcp/clients/*
quarkus.http.auth.permission.mcp-status.policy=permit

# CORS (dev: permissive, prod: locked down)
quarkus.http.cors.enabled=true
quarkus.http.cors.origins=/.*/
%prod.quarkus.http.cors.origins=${HENSU_CORS_ORIGINS:}
%prod.quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
%prod.quarkus.http.cors.headers=Authorization,Content-Type,Accept

# TLS - production
%prod.quarkus.http.insecure-requests=redirect
%prod.quarkus.http.ssl-port=8443
%prod.quarkus.http.ssl.certificate.files=${HENSU_TLS_CERT_FILE:}
%prod.quarkus.http.ssl.certificate.key-files=${HENSU_TLS_KEY_FILE:}

# API Credentials
# Configure API keys here or via environment variables (e.g., ANTHROPIC_API_KEY).
# hensu.credentials.ANTHROPIC_API_KEY=sk-ant-...
# hensu.credentials.OPENAI_API_KEY=sk-...
# hensu.credentials.GOOGLE_API_KEY=...
# hensu.credentials.DEEPSEEK_API_KEY=...

# MCP Configuration
hensu.mcp.connection-timeout=30s
hensu.mcp.read-timeout=60s
hensu.mcp.pool-size=10

# Planning Configuration
hensu.planning.default-max-steps=10
hensu.planning.default-max-replans=3
hensu.planning.default-timeout=5m

# PostgreSQL
# Dev:  connects to local docker-compose container (Dev Services disabled).
#       Set HENSU_DB_USER, HENSU_DB_PASSWORD, HENSU_DB_NAME in .env - see .env.example.
# Prod: set HENSU_DB_URL, HENSU_DB_USER, HENSU_DB_PASSWORD as environment variables.
quarkus.datasource.db-kind=postgresql
%dev.quarkus.datasource.devservices.enabled=false
%dev.quarkus.datasource.username=${HENSU_DB_USER}
%dev.quarkus.datasource.password=${HENSU_DB_PASSWORD}
%dev.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/${HENSU_DB_NAME:hensu}
%prod.quarkus.datasource.username=${HENSU_DB_USER}
%prod.quarkus.datasource.password=${HENSU_DB_PASSWORD}
%prod.quarkus.datasource.jdbc.url=${HENSU_DB_URL}

# Flyway schema migrations
quarkus.flyway.migrate-at-start=true
quarkus.flyway.schemas=runtime

# Default tenant (dev only - LaunchMode guard in RequestTenantResolver prevents production use)
%dev.hensu.tenant.default=dev-tenant

# In-memory profile: disables PostgreSQL and auth - for integration tests only, not local dev.
%inmem.quarkus.datasource.active=false
%inmem.quarkus.datasource.devservices.enabled=false
%inmem.quarkus.flyway.migrate-at-start=false
%inmem.quarkus.http.auth.permission.api.policy=permit
%inmem.quarkus.http.auth.permission.mcp.policy=permit

# Distributed recovery leasing
# hensu.node.id=              # auto-generated UUID on startup if blank
hensu.lease.heartbeat-interval=30s
hensu.lease.recovery-interval=60s
hensu.lease.stale-threshold=90s
# Disable scheduler in in-memory mode - no JDBC, no leasing needed
%inmem.quarkus.scheduler.enabled=false
