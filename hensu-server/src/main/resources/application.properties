# Hensu Server Configuration

# HTTP Server
quarkus.http.port=8080
quarkus.http.host=0.0.0.0

# HTTP/3 (QUIC) Support
# Requires TLS and vertx-http3 dependency - uncomment when SSL is configured
# quarkus.http.insecure-requests=redirect
# quarkus.http.ssl-port=8443

# SSL/TLS Configuration (required for HTTP/3)
# For development, generate a self-signed certificate:
#   keytool -genkeypair -alias hensu -keyalg RSA -keysize 2048 \
#     -storetype PKCS12 -keystore hensu-keystore.p12 -validity 365 \
#     -storepass changeit -dname "CN=localhost"
#
# Then uncomment these lines:
# %dev.quarkus.http.ssl.certificate.key-store-file=hensu-keystore.p12
# %dev.quarkus.http.ssl.certificate.key-store-password=changeit

# Production SSL (configure via environment variables or config)
# quarkus.http.ssl.certificate.files=/path/to/cert.pem
# quarkus.http.ssl.certificate.key-files=/path/to/key.pem
# quarkus.http.ssl-port=443

# Application
quarkus.application.name=hensu-server
hensu.stub.enabled=false

# Native image: bundle stub response files so getResourceAsStream works at runtime.
# StubResponseRegistry builds paths dynamically (/stubs/{scenario}/{key}.txt),
# which GraalVM cannot trace statically - explicit inclusion is required.
quarkus.native.resources.includes=stubs/**

# Logging
quarkus.log.level=INFO
quarkus.log.category."io.hensu".level=DEBUG

# JWT Authentication
mp.jwt.verify.publickey.location=${HENSU_JWT_PUBLIC_KEY:publicKey.pem}
mp.jwt.verify.issuer=${HENSU_JWT_ISSUER:https://hensu.io}

# Auth policy - require authentication for API and MCP paths
quarkus.http.auth.permission.api.paths=/api/*
quarkus.http.auth.permission.api.policy=authenticated
quarkus.http.auth.permission.mcp.paths=/mcp/connect,/mcp/message
quarkus.http.auth.permission.mcp.policy=authenticated
quarkus.http.auth.permission.mcp-status.paths=/mcp/status,/mcp/clients/*
quarkus.http.auth.permission.mcp-status.policy=permit

# CORS (dev: permissive, prod: locked down)
quarkus.http.cors.enabled=true
quarkus.http.cors.origins=/.*/
%prod.quarkus.http.cors.origins=${HENSU_CORS_ORIGINS:}
%prod.quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
%prod.quarkus.http.cors.headers=Authorization,Content-Type,Accept

# TLS - production
%prod.quarkus.http.insecure-requests=redirect
%prod.quarkus.http.ssl-port=8443
%prod.quarkus.http.ssl.certificate.files=${HENSU_TLS_CERT_FILE:}
%prod.quarkus.http.ssl.certificate.key-files=${HENSU_TLS_KEY_FILE:}

# API Credentials
# Configure API keys here or via environment variables (e.g., ANTHROPIC_API_KEY).
# hensu.credentials.ANTHROPIC_API_KEY=sk-ant-...
# hensu.credentials.OPENAI_API_KEY=sk-...
# hensu.credentials.GOOGLE_API_KEY=...
# hensu.credentials.DEEPSEEK_API_KEY=...

# MCP Configuration
hensu.mcp.connection-timeout=30s
hensu.mcp.read-timeout=60s
hensu.mcp.pool-size=10

# Planning Configuration
hensu.planning.default-max-steps=10
hensu.planning.default-max-replans=3
hensu.planning.default-timeout=5m

# PostgreSQL (Dev Services auto-starts a container in dev/test mode)
quarkus.datasource.db-kind=postgresql
%prod.quarkus.datasource.username=hensu
%prod.quarkus.datasource.password=hensu
%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hensu

# Flyway schema migrations
quarkus.flyway.migrate-at-start=true
quarkus.flyway.schemas=hensu

# Default tenant (dev/test only - LaunchMode guard in RequestTenantResolver prevents production use)
%dev.hensu.tenant.default=dev-tenant

# In-memory profile disables PostgreSQL, uses in-memory repositories
%inmem.quarkus.datasource.active=false
%inmem.quarkus.datasource.devservices.enabled=false
%inmem.quarkus.flyway.migrate-at-start=false
%inmem.quarkus.http.auth.permission.api.policy=permit
%inmem.quarkus.http.auth.permission.mcp.policy=permit

# Distributed recovery leasing
# hensu.node.id=              # auto-generated UUID on startup if blank
hensu.lease.heartbeat-interval=30s
hensu.lease.recovery-interval=60s
hensu.lease.stale-threshold=90s
# Disable scheduler in in-memory mode â€” no JDBC, no leasing needed
%inmem.quarkus.scheduler.enabled=false
