package io.hensu.core.plan;

import java.util.List;
import java.util.Objects;
import java.util.UUID;

/// Represents an execution plan (static or LLM-generated).
///
/// Plans define a sequence of tool invocations to achieve a goal. They are
/// created by {@link Planner} implementations and executed by {@link PlanExecutor}.
///
/// ### Plan Sources
/// - **STATIC**: Defined in DSL via `plan { step(...) }` blocks
/// - **LLM_GENERATED**: Created at runtime by an LLM planner
///
/// ### Contracts
/// - **Precondition**: `id`, `nodeId` must not be null
/// - **Postcondition**: All fields immutable after construction
///
/// ### Usage
/// {@snippet :
/// Plan staticPlan = Plan.staticPlan(
///     "process-order",
///     List.of(
///         PlannedStep.pending(0, "get_order", Map.of("id", "{orderId}"), "Fetch order"),
///         PlannedStep.pending(1, "validate", Map.of(), "Validate order")
///     )
/// );
/// }
///
/// @param id unique plan identifier, not null
/// @param nodeId the workflow node this plan belongs to, not null
/// @param source how the plan was created, not null
/// @param steps ordered list of steps to execute, not null
/// @param constraints execution limits, not null
/// @see Planner for plan creation
/// @see PlanExecutor for plan execution
public record Plan(
        String id,
        String nodeId,
        PlanSource source,
        List<PlannedStep> steps,
        PlanConstraints constraints) {

    /// How the plan was created.
    public enum PlanSource {
        /// Defined in DSL at compile time
        STATIC,
        /// Generated by LLM at runtime
        LLM_GENERATED
    }

    /// Compact constructor with validation.
    public Plan {
        Objects.requireNonNull(id, "id must not be null");
        Objects.requireNonNull(nodeId, "nodeId must not be null");
        source = source != null ? source : PlanSource.STATIC;
        steps = steps != null ? List.copyOf(steps) : List.of();
        constraints = constraints != null ? constraints : PlanConstraints.defaults();
    }

    /// Creates a static plan with default constraints.
    ///
    /// @param nodeId the workflow node, not null
    /// @param steps ordered steps, not null
    /// @return new static plan, never null
    public static Plan staticPlan(String nodeId, List<PlannedStep> steps) {
        return new Plan(
                UUID.randomUUID().toString(),
                nodeId,
                PlanSource.STATIC,
                steps,
                PlanConstraints.forStaticPlan());
    }

    /// Creates a dynamic plan with default constraints.
    ///
    /// @param nodeId the workflow node, not null
    /// @param steps ordered steps, not null
    /// @return new dynamic plan, never null
    public static Plan dynamicPlan(String nodeId, List<PlannedStep> steps) {
        return new Plan(
                UUID.randomUUID().toString(),
                nodeId,
                PlanSource.LLM_GENERATED,
                steps,
                PlanConstraints.defaults());
    }

    /// Returns whether this is a static (DSL-defined) plan.
    ///
    /// @return true if source is STATIC
    public boolean isStatic() {
        return source == PlanSource.STATIC;
    }

    /// Returns whether this plan has any steps.
    ///
    /// @return true if steps list is not empty
    public boolean hasSteps() {
        return !steps.isEmpty();
    }

    /// Returns the number of steps.
    ///
    /// @return step count
    public int stepCount() {
        return steps.size();
    }

    /// Returns a step by index.
    ///
    /// @param index zero-based step index
    /// @return the step at index
    /// @throws IndexOutOfBoundsException if index is out of range
    public PlannedStep getStep(int index) {
        return steps.get(index);
    }

    /// Returns a copy with updated steps.
    ///
    /// @param newSteps the new steps, not null
    /// @return new plan with updated steps, never null
    public Plan withSteps(List<PlannedStep> newSteps) {
        return new Plan(id, nodeId, source, newSteps, constraints);
    }

    /// Returns a copy with updated constraints.
    ///
    /// @param newConstraints the new constraints, not null
    /// @return new plan with updated constraints, never null
    public Plan withConstraints(PlanConstraints newConstraints) {
        return new Plan(id, nodeId, source, steps, newConstraints);
    }
}
